<!--
	作者：Sariay
	时间：2018-09-25
	描述：There may be a bug, but don't worry, QiLing(器灵) says that it can work normally!
-->
<!DOCTYPE html>
<html class="html-loading">
		

<head><meta name="generator" content="Hexo 3.9.0">
	<meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <title>
    
      一些面试知识点 | Sweet Blog
    
  </title>
  <meta name="author" content="Sweet Coder">
  <meta name="keywords" content>
  <meta name="description" content>
	<!-- favicon -->
  <link rel="shortcut icon" href="/img/favicon.ico">

  <!-- css -->
  <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/Annie.css">
  
  <!-- jquery -->
	<script src="/js/jquery.min.js"></script>

  <!-- leancloud -->
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
<script src="/js/leancloud.js"></script>
</head>
	<body>
		<!-- Preloader -->

	<div id="preloader">
		<div class="pre-container">
			
				<div class="spinner">
					<div class="double-bounce1"></div>
					<div class="double-bounce2"></div>
				</div>
						
		</div>
	</div>


<!-- header -->
<header class="fixbackground" data-img-mode="random" data-normal-src="/" data-random-max="7" data-random-src="/img/Random_img/">
	<div class="mask">
		<!-- Logo and navigation -->
		<div class="h-header">
			<div id="logo">
				<a href="/">
						
						<img src="/img/Signature.png" alt="Logo">
					
				</a>
			</div>
			
			<div id="navigation-show">
				<ul>
	
		<li class="menu-主页">
			<a href="/" class="menu-item-主页">主页</a>
		</li>
	
		<li class="menu-归档">
			<a href="/archives" class="menu-item-归档">归档</a>
		</li>
	
		<li class="menu-分类">
			<a href="/categories" class="menu-item-分类">分类</a>
		</li>
	
		<li class="menu-标签">
			<a href="/tags" class="menu-item-标签">标签</a>
		</li>
	
		<li class="menu-关于">
			<a href="/about" class="menu-item-关于">关于</a>
		</li>
	
		<li class="menu-相册">
			<a href="/gallery" class="menu-item-相册">相册</a>
		</li>
	

	
</ul>
			</div>				
		</div>

		<!-- motto -->
		<div class="h-body">	
			
				<p class="motto"></p>
			
		</div>
		
		<!-- others: such as time... -->			
		<div class="h-footer">
			<a href="javascript:;" id="read-more"><i class="fa fa-angle-double-down" aria-hidden="true"></i>
			</a>

			
				<!-- 
	This is only a demo, please go to "https://time.is" to set your city time! 
-->
<style type="text/css">
	.header-date {
		font-size: 1.6rem;
		color: #fff;
		position: absolute;
		bottom: 5px;
		right: 1rem;
		writing-mode: tb-rl;
	}	
	
	.header-date a {
		border-bottom: none;
	}

	@media only screen and (max-width: 768 ) {
		.header-date {
			font-size: 1rem;
		}			
	}
</style>
<div class="header-date">
	<a href="https://time.is/Beijing" id="time_is_link" rel="nofollow" ></a>
	<span id="Beijing_z43d"></span>
</div>
<script src="//widget.time.is/zh.js"></script>
<script>
	time_is_widget.init({
		Beijing_z43d:{
			template:"DATE", 
			date_format:"year年 monthname dnum日"
		}
	});
</script>
			
		</div>
	</div>
</header>

<div id="navigation-hide">
	<!-- Progress bar -->
	<div id="progress-bar"></div>

	<!-- Progress percent -->
	<div id="progress-percentage"><h1>0.0%</h1></div>

	<div class="toc-switch"><span class="switch-button">Catalog</span></div>

	<!-- Page title -->
	<p>
		
			Current post&nbsp;:&nbsp;《一些面试知识点》
		
	</p>

	<!-- Nav trigger for navigation-H-->
	<a class="nav-trigger"><span></span></a>
</div>

<!-- Navigation in div(id="navigation-H") -->
<nav class="nav-container" id="cd-nav">
	<div class="nav-header">
		<h3>Navigation</h3>
		<a href="javascript:;" class="nav-close"></a>
	</div>
	<div class="nav-body">
		<ul>
	
		<li class="menu-主页">
			<a href="/" class="menu-item-主页">主页</a>
		</li>
	
		<li class="menu-归档">
			<a href="/archives" class="menu-item-归档">归档</a>
		</li>
	
		<li class="menu-分类">
			<a href="/categories" class="menu-item-分类">分类</a>
		</li>
	
		<li class="menu-标签">
			<a href="/tags" class="menu-item-标签">标签</a>
		</li>
	
		<li class="menu-关于">
			<a href="/about" class="menu-item-关于">关于</a>
		</li>
	
		<li class="menu-相册">
			<a href="/gallery" class="menu-item-相册">相册</a>
		</li>
	

	
</ul>
	</div>
	<div class="nav-footer">
		<ul>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-github"></i>
			</a>
		</li>
	
		<li>
			<a href="https://weibo.com/5809441156/profile?rightmod=1&wvr=6&mod=personnumber&is_all=1" target="_blank">
				<i class="fa fa-weibo"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-pinterest"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-instagram"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-twitter"></i>
			</a>
		</li>
	
		<li>
			<a href="/atom.xml" target="_blank">
				<i class="fa fa-rss"></i>
			</a>
		</li>
			
</ul>

	</div>
</nav>
			
		<!--main-->
		<main>
			<!--
	时间：2018-11-17
	描述：
		插件名称：katelog.min.js
		插件作者：KELEN
		插件来源: https://github.com/KELEN/katelog
-->

	
		<div class="layout-toc">
			<div id="layout-toc">
				<div class="k-catelog-list" id="catelog-list" data-title="文章目录"></div>
			</div>
		</div>

		
		<script src="/plugin/toc/katelog.min.js"></script>

		
	 

<div class="layout-post">
	<div id="layout-post">
	<div class="article-title">
		<i class="fa fa-paper-plane-o" aria-hidden="true"></i>
		
	<a href="/2020/06/03/一些面试问题/" itemprop="url">
		一些面试知识点
	</a>

	</div>

	<div class="article-meta">
		<span>
			<i class="fa fa-calendar"></i>
			


	Posted on

	<a href="/2020/06/03/一些面试问题/" itemprop="url">
		<time datetime="2020-06-03T09:38:30.000Z" itemprop="datePublished">
	  		2020-06-03
	  </time>
	</a>
	&nbsp;





			




	Updated on

	<a href="/2020/06/03/一些面试问题/" itemprop="url">
		<time datetime="2020-06-03T09:38:30.000Z" itemprop="dateUpdated">
	  		2020-09-01
	  </time>
	</a> 



		</span>
		<span>
			<i class="fa fa-tags"></i>
			
	
		<a href="/tags/面试/" class=" ">
			面试
		</a>
	
		
		</span>
		
		



	</div>

	<div class="article-content" id="article-content">
		<h3 id="一些面试会问到的东西"><a href="#一些面试会问到的东西" class="headerlink" title="一些面试会问到的东西"></a>一些面试会问到的东西</h3><p>这次实习面试经历了几个大厂的面试，总结了一些问题，但是很遗憾当时只是记一下方便复习并没有组成体系，如果后面有时间的话我会把这些内容完善并整理成体系。</p>
<h2 id="网络层次模型"><a href="#网络层次模型" class="headerlink" title="网络层次模型"></a>网络层次模型</h2><p><strong>osi七层模型</strong></p>
<ul>
<li>应用层：面向计算机用户，提供程序和网络的接口</li>
<li>表示层：处理来自应用层的命令和数据，对各种语法解释，按照规格传给会话层（处理编码，数据可以使转换和加密解密）</li>
<li>会话层：会话层作用是负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。常见的协议有 ADSP、RPC 等</li>
<li>传输层：为会话层和网络层提供传输服务，从会话层获得数据，在必要时进行分割，然后传送给网络层，主要起到建立，维护和取消传输连接功能，负责两节点的可靠传输</li>
<li>网络层：通过路由算法，为报文选择最合适的路径，在网络层数据转化为数据包，通过路径选择等控制，将信息从一个网络设备传递到另一个网络设备（主要任务是寻址和路由选择）</li>
<li>数据链路层：以帧为单元封装网络层的数据，以及分析物理层传输过来的数据帧，该层负责物理层面上互连的节点之间的通信传输</li>
<li>物理层：为数据链路层提供数据帧，接收数据帧然后管理电脑通信设备和网络媒体之间的互通，包括了针脚、电压、线缆规范、集成器、中继器、网卡、主机适配器等</li>
</ul>
<p><strong>tcp/ip四层模型</strong></p>
<ul>
<li>应用层（应用、表示、会话）</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层（数据链路层、物理层）</li>
</ul>
<h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><p><strong>UDP</strong></p>
<ul>
<li>UDP的报头设置：8个字节</li>
<li>一对一、一对多和多对一</li>
<li>搞清楚UDP的校验码是如何产生的</li>
</ul>
<p><strong>TCP</strong></p>
<ul>
<li><p>TCP的报头：前二十个固定的字节，包括两个端口号（4）、两个序号（8）、数据偏移（4Bit）、保留为（6Bit）和信号位（6Bit）、以及窗口（1）、检验和（1）和紧急指针（1）</p>
</li>
<li><p>流量控制：发送方会受到接收方的调整，通过滑动窗口</p>
<ul>
<li>注意为了节省带宽，sender不是已有消息就发送</li>
<li>receiver也不是只要有空间就会发出确认信号，都是需要进行调节的</li>
</ul>
</li>
<li><p>拥塞控制：主要有四种算法，即慢开始、拥塞避免、快重传和快恢复</p>
<ul>
<li><p>慢开始：cwnd按照1， 2， 4， 8的大小递增</p>
</li>
<li><p>拥塞避免：当窗口大小增加到ssthresh时开始使用拥塞避免算法，即每次cwnd增加1</p>
<p>如果报文超时，则表明出现拥塞，会把ssthresh设为原来的一半，然后开始慢开始算法</p>
</li>
<li><p>快重传：当报文丢失而不是出现拥塞时，接收方不等待自己发送数据时才捎带，而是立即发送丢失前一个包的确认号码，发送方接收三次之后会立即进行重传</p>
</li>
<li><p>快恢复：在上文知道是丢包而不是拥塞之后会调整ssthresh为原来的一半，而不是重新开始</p>
</li>
</ul>
</li>
</ul>
<p><strong>为啥要三次握手</strong></p>
<ul>
<li>如果只有两次：第一次client发送的SYN延迟，那么client就会重新发送，此时server返回SYN和ACK，如果结束之后第一次SYN到了，那么server也会返回SYN和ACK，那么此时建立的连接就是多余的了</li>
<li>三次握手会等到client发回确认之后再建立连接，更可靠</li>
</ul>
<p><strong>第三次ACK确认包丢失之后咋办</strong></p>
<ul>
<li>服务端会重新发回ACK包，有可能会造成泛洪攻击</li>
<li>服务端发送RST报文，直接进入CLOSE状态，要想重新连接就要从第一次握手开始</li>
</ul>
<p><strong>四次挥手最后一个ACK丢失怎么办</strong></p>
<ul>
<li>客户端受到服务端FIN之后会开一个计时器，如果客户端返回的ACK丢失，那么客户端还会重发FIN并重置计时器，加入计时器失效，那么客户端CLOSE。那么服务端无法收到ACK而无法关闭，时间长了会触发TCP的保活计时器。</li>
</ul>
<h2 id="https与http"><a href="#https与http" class="headerlink" title="https与http"></a>https与http</h2><p><strong>http不同版本</strong></p>
<ul>
<li>HTTP/0.9（1991）<ul>
<li>只有一个GET，Server只能返回HTML字符串</li>
</ul>
</li>
<li>HTTP/1.0（1996.05）<ul>
<li>任何格式的内容都可以，文字、视频、二进制</li>
<li>引入了POST和HEAD</li>
<li>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据</li>
<li>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等</li>
<li>回应格式是头信息+空行+数据</li>
<li>缺点：<ul>
<li>请求完之后及关闭，每次求情都是重连，并且请求刚开始的时候是慢开始，发送速率并不高</li>
<li>有些浏览器会加上Connection: keep-alive，但这并不是标准字段</li>
</ul>
</li>
</ul>
</li>
<li>HTTP/1.1（1997.01）<ul>
<li>持久连接成为标准，默认不关闭，主动关闭用Connection: close，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</li>
<li>管道机制（pipeling）：允许client同时发出多个请求，并且按顺序返回，不再是发一个等返回之后才能继续发送另一个</li>
<li>Content-Length成为必须，因为会连续返回，要知道这个返回包的大小，和下一个完成区分</li>
<li>分块传输编码：Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度<ul>
<li>只有处理完了所有的才能知道长度，这样显然效率不高</li>
<li>采用Stream流模式，处理完一块就就发一块</li>
<li>Transfer-Encoding: chunked</li>
<li>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。</li>
</ul>
</li>
<li>增加了：PUT、PATCH、HEAD、OPTIONS、DELETE</li>
<li>增加Host字段：有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础</li>
<li>缺点：对头阻塞，因为http1.1虽然允许复用，但是服务器的处理顺序是按顺序进行的</li>
<li>解决方法：减少请求数量，或者同时多开持久连接</li>
</ul>
</li>
<li>SPYD协议<ul>
<li>2009年谷歌自行研发的协议用于Chrome，解决HTTP1.1的效率问题</li>
<li>在Chrome上证明可行之后被当做HTTP/2.0的基础</li>
</ul>
</li>
<li>HTTP/2（2015）<ul>
<li>彻头彻尾的二进制协议，头和数据体都是二进制，统称为frame（帧）</li>
<li>多工：在一个TCP链接里，客户端和浏览器都可以同时发送多个请求，不用顺序，避免对头阻塞（双向的，实时的通信）</li>
<li>数据流：数据包不是按顺序发送，同一个连接中连续的数据包可能属于不同的回应，要对数据包进行标记</li>
<li>所有数据包也称为Stream，每个都有独一无二的编号。</li>
<li>因此数据包发送的时候必须要有流的ID，客户端的流ID为奇数，服务端为偶数</li>
<li>数据流发送到一半的时候可以取消（RSET_STREAM帧），1.1只能关闭TCP</li>
<li>客户端还可以指定数据流的优先级</li>
<li>头信息压缩：<ul>
<li>HTTP协议无状态：每次请求都会上传所有的头信息，浪费带宽</li>
<li>HTTP/2引入了头压缩机制，一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了</li>
</ul>
</li>
<li>服务器主动推送</li>
</ul>
</li>
</ul>
<p><strong>http1与http2</strong></p>
<ul>
<li>http2增加的新特性：<ol>
<li>采用二进制而不是明文进行打包</li>
<li>多路复用</li>
<li>修复对头阻塞</li>
<li>允许设定请求优先级</li>
<li>服务器推送</li>
<li>WebSocket</li>
</ol>
</li>
</ul>
<p><strong>POST与GET</strong></p>
<ul>
<li>副作用：对服务器上的资源做出改变，GET是不会改变服务器上的资源的</li>
<li>幂等：发送M次请求和发送N次请求（二者不同且都大于一），服务器上的资源状态度一致，比如说你向服务器一直请求支援也不会改变服务器上的资源状态，但是一旦你一直POST就不一样了</li>
<li>GET多用于无副作用并且是幂等的场景，POST多用于有副作用并且是不幂等的场景</li>
<li>技术上来说：<ul>
<li>GET可以缓存，POST不能，例如常见的静态资源不用每次获取，浏览器可以设置是否缓存，刷新回退操作都是会导致POST重复提交表单</li>
<li>POST相对安全，GET请求都在URL中，会被浏览器保存记录，而POST不会，抓包时是一样的</li>
<li>POST可以使用Request Body传输比GET更多的数据</li>
<li>URL长度会受到浏览器的影响，会影响GET</li>
<li>POST支持更多的编码类型且不对数据类型限制，GET只支持ASCII</li>
</ul>
</li>
</ul>
<p><strong>常见状态码</strong></p>
<ul>
<li>1xx：正在处理请求</li>
<li>2xx：成功<ul>
<li>200 OK client请求被正确处理</li>
<li>204 请求成功，但是响应不包含实体的主体部分</li>
<li>206 范围请求，与请求头中的Range参数相关联</li>
</ul>
</li>
<li>3xx：重定向<ul>
<li>301 永久性的重定向，资源已经被分配到新的url</li>
<li>302 临时性的重定向</li>
<li>303 表示资源存在另一个URL，应该以GET获取</li>
<li>304 表示允许访问资源，但是请求条件未满足</li>
<li>307 临时重定向，同302</li>
</ul>
</li>
<li>4xx：客户端错误<ul>
<li>400 请求报文语法错误</li>
<li>401 未认证</li>
<li>403 请求的资源被服务器禁止访问</li>
<li>404 not found</li>
</ul>
</li>
<li>5xx：服务器错误<ul>
<li>501：服务器内部错误，执行请求时出错</li>
<li>502：处于超负荷，无法处理请求</li>
</ul>
</li>
</ul>
<p><strong>常见的http方法</strong></p>
<ul>
<li>GET：通常用于向服务器请求资源</li>
<li>POST：传输实体主体，主要目的是传输而不是为了获取资源</li>
<li>HEAD：请求资源的头信息，常用于试探性的请求（相当于是使用GET但是服务器只返回相关的头部）<ul>
<li>可以用于试探性的检验服务器相关的资源的大小，确认是否下载</li>
<li>也可以获取资源的有效性和相关的更新时间，用于确定是否可以进一步请求</li>
</ul>
</li>
<li>OPTIONS：用于获取目的资源所支持的通信选项</li>
<li>PUT：传输文件，就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，保存到指定URI的位置<ul>
<li>http/1.1的PUT方法自身不带验证机制，需要配合web安全程序的使用，或者是采用REST标准</li>
</ul>
</li>
<li>DELETE：用于删除文件，删除URI指定的资源，与PUT恰恰相反，同样是没有验证机制，使用的时候需要注意</li>
<li>TRACE：让web服务器将之前的请求通信还回给客户端，用于查看从客户端到达服务器中间经历的代理服务器</li>
<li>CONNECT：要求与代理服务器之间在通信时建立信道，主要是SSL（Security Sockets Layer）和TSL（Transport Layer Secutiry）</li>
</ul>
<p><strong>HTTP缓存机制</strong></p>
<ul>
<li>缓存的规则：缓存什么？<ul>
<li>强制缓存：当客户端请求时回先从缓存中查找</li>
<li>协商缓存：客户端从缓存中获取缓存标识，请求服务端检验是否有效，有效返回304，无效服务端返回更新数据</li>
</ul>
</li>
<li>缓存的方案：缓存信息存储在报文中的头部<ul>
<li>Expires（HTTP/1.0）：服务端返回数据到期时间，再次请求时间小于这个强制使用缓存</li>
<li>Cache-Control：<ul>
<li>private：客户端可以缓存</li>
<li>public：客户端和代理服务器都可以缓存 </li>
<li>max-age=t：缓存内容将在t秒后失效</li>
<li>no-cache：需要使用协商缓存来验证缓存数据 </li>
<li>no-store：所有内容都不会缓存。</li>
</ul>
</li>
<li>协商缓存：客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了<ul>
<li>Last-Modified：资源的最后修改时间<ul>
<li>if-Modified-Since：如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK，如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified</li>
<li>if-Unmodified-Since：如果没有被修改:则开始`继续’传送文件: 服务器返回: 200 OK，</li>
</ul>
</li>
<li>Etag： 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）<ul>
<li>If-None-Match： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比</li>
<li>不同，说明资源被改动过，则响应整个资源内容，返回状态码200，相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304</li>
</ul>
</li>
</ul>
</li>
<li>浏览器输入URL会先试一试缓存，F5让浏览器去服务器看看缓存过期没，Ctrl+F5强制刷新</li>
</ul>
</li>
</ul>
<h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul>
<li>volatile可以禁止JVM进行命令的重排</li>
<li>synchronized：<ol>
<li>修饰代码块：JVM底层是monitorenter和monitorexit命令，包裹着同步代码</li>
<li>修饰方法：ACC_SYNCHRONIZED，指明方法是一个同步方法，JVM执行时同步调用</li>
<li>JDK1.6之后的synchronized引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应自旋锁、锁消除和锁粗化来减少锁的开销</li>
<li>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</li>
</ol>
</li>
</ul>
<ol>
<li>int范围： 应该是一个比较考你平时有没有注意到，个人认为你只要搞清楚int是多少个bit就可以了，不过如果你能记住大概是在±20亿之间应该会增加面试官对你的好感。</li>
</ol>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><strong>主要变量</strong></p>
<ul>
<li>序列UID</li>
<li>DEFAULT_INITIAL_CAPACITY：默认的容量</li>
<li>MAXIMUM_CAPACITY：最大容量 1&lt;&lt;30</li>
<li>DEFAULT_LOAD_FACTOR：默认的负载因子</li>
<li>TREEIFY_THRESHOLD：拉链到红黑树的阈值</li>
<li>UNTREEIFY_THRESHOLD：红黑树转为拉链的阈值</li>
<li>MIN_TREEIFY_CAPACITY：</li>
<li>table：Node节点的数组</li>
<li>entrySet：</li>
<li>size：HashMap的大小</li>
<li>modCount：改动次数，在并发的时候有快速失败的作用</li>
<li>threshold：阈值</li>
<li>loadFactor：负载因子</li>
</ul>
<p>阅读官方文档：</p>
<ul>
<li>不保证同步，允许key和value为null</li>
<li>This class makes no guarantees as to the order of the map</li>
<li>(<code>get</code> and <code>put</code>)是常数时间</li>
<li>为了迭代性能，不要将capacity设置的过高或者负载因子过低</li>
<li>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs</li>
<li>(A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with a key that an instance already contains is not a structural modification.) 结构的改变不包括改变HashMap中已有key的value</li>
<li>面对并发时候的修改，迭代器会快速地失败，而不是后面去冒险</li>
<li>containsKey(Object key)并不是看是不是真的有没有key，而是看有没有这个节点Node，getNode()</li>
<li>keySet和values都是map支持的，删除修改他们的值，map也会修改，这两个东西都是通过HashMap内部的类完成的，有很多东西都是直接调用的HashMap中的</li>
<li>计算hash的时候，如果key是null，hash值是0</li>
<li>resize的时候会有rehash的过程：newTab[j + oldCap] = hiHead;</li>
</ul>
<p><strong>关键方法</strong></p>
<ul>
<li><p>void clear() </p>
</li>
<li><p>Object clone()   shallow copy</p>
</li>
<li><p>compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)   Attempts to compute a mapping for the specified key and its current mapped value (or <code>null</code> if there is no current mapping).</p>
</li>
<li><p>computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)   If the specified key is not already associated with a value (or is mapped to <code>null</code>), attempts to compute its value using the given mapping function and enters it into this map unless <code>null</code>.</p>
</li>
<li><p>computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)   If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value.</p>
</li>
<li><p>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</p>
<p>返回一个Set view的entry</p>
</li>
<li><p>V merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</p>
<p>If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value.</p>
</li>
</ul>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><strong>主要变量</strong></p>
<ul>
<li>table：同HashMap，实现了Map.Entry接口，是一个Node的类型数组</li>
<li>nexttable：哈希表扩容时候生成的数据，数组为原来的两倍</li>
<li>sizeCtl：多个线程的共享变量，是操作的控制标识符，它的作用不仅包括threshold的作用，在不同的地方有不同的值也有不同的用途<ol>
<li>-1代表正在初始化</li>
<li>-N代表有N-1个线程正在进行扩容操作</li>
<li>0代表hash表还没有被初始化</li>
<li>正数表示下一次进行扩容的容量大小</li>
</ol>
</li>
<li>ForwardingNode：一个特殊的Node节点，Hash地址为-1，存储着nextTable的引用，只有table发生扩用的时候，ForwardingNode才会发挥作用，作为一个占位符放在table中表示当前节点为null或者已被移动</li>
</ul>
<p>主要知识点：</p>
<ul>
<li>支持检索的并发性和更高的更新并发性</li>
<li>检索并不会锁定，所以可能会与put或是delete操作做重叠</li>
<li>迭代器并不会ConcurrentModificationException抛出异常，但是迭代器被设计成一次只能由一个线程使用</li>
<li>ConcurrentHashMap：通过CAS和synchronized一起保证并发的安全性，且不支持锁定整个表</li>
<li>resize()无论何时都是一个slow operation</li>
<li>当key可比较的时候，会用key的比较顺序</li>
<li>ConcurrentHashMap的key和value都不为null，与HashTable一致</li>
</ul>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ul>
<li>同步代码块：通过monitorenter和monitorexit指令实现的（每个对象都有一个监视器）</li>
<li>同步方法：加了synchronized标识的方法在方法域中比普通方法多了一个ACC_SYNCHRONIZED，JVN以此判断同步</li>
<li>monitorenter：如果monitor为0则进入，设置为1，表示该线程成为monitor对所有者，以后每次重入时加1</li>
<li>monitorexit：持有monitor线程出来时进行减1操作</li>
<li>同步实例方法</li>
<li>同步类方法</li>
<li>同步代码块：具体同步的是实例还是类要看（）中的修饰</li>
<li>synchronized方法在就加锁之前清空工作区内存，保证所有的都是从主存中获取的</li>
<li>synchronized方法在解锁之前要将工作取得变量副本写回到主存中，保证读写的原子性</li>
<li>synchronized是非公平锁</li>
</ul>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><ul>
<li><p>递归遍历，这个很简单</p>
</li>
<li><p>主要是非递归的遍历</p>
<ol>
<li><p>中根遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先遍历左子节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span>(!s.isEmpty() || cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.isEmpty()) &#123;</span><br><span class="line">            cur = s.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先遍历右子节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span>(!s.isEmpty() || cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(cur);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.isEmpty()) &#123;</span><br><span class="line">            cur = s.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先根遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.isEmpty()) &#123;</span><br><span class="line">        cur = s.pop();</span><br><span class="line">        res.add(cur.val);</span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后根遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//two stacks</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">lastRoot</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; out = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    s.push(root);</span><br><span class="line">    TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s.isEmpty()) &#123;</span><br><span class="line">        cur = s.pop();</span><br><span class="line">        out.push(cur);</span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!out.isEmpty()) &#123;</span><br><span class="line">        cur = out.pop();</span><br><span class="line">        res.add(cur.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dequeen</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">lastRootDeQueen</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    s.push(root);</span><br><span class="line">    TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s.isEmpty()) &#123;</span><br><span class="line">        cur = s.pop();</span><br><span class="line">        res.addFirst(cur.val);</span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li><p>恶汉式-静态变量方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//直接在类加载的时候初始化，天然的线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>饿汉式-静态代码块：只是将初始化放到了静态代码块中</p>
</li>
<li><p>懒汉式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//保证了各线程对静态实例修改的可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//多个线程进入的时候会有问题</span></span><br><span class="line">            <span class="comment">//如果代码重排也会有问题</span></span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加上锁之后可以，但是效率会出现问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//多个线程进入的时候会有问题</span></span><br><span class="line">            <span class="comment">//如果代码重排也会有问题</span></span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果不为null的话可以直接返回，不用每次对方法进行加锁</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//只对初始化的时候加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Callable-Future-FutureTask"><a href="#Callable-Future-FutureTask" class="headerlink" title="Callable,Future,FutureTask"></a>Callable,Future,FutureTask</h2><p>Callable和Future可以获得线程执行之后的结果</p>
<p><strong>Callable</strong></p>
<ul>
<li>是一个抽象接口，有一个泛型参数，里面的call()函数会返回泛型参数类型的结果</li>
</ul>
<p><strong>Future</strong></p>
<ul>
<li>顾名思义：可以查询Runnable和Callable的执行结果</li>
<li>重点是get()方法，这个方法会获取执行结果，会阻塞直到任务返回</li>
</ul>
<h2 id="静态域和静态方法"><a href="#静态域和静态方法" class="headerlink" title="静态域和静态方法"></a>静态域和静态方法</h2><ul>
<li>静态域：主要是静态变量和静态常量，其中静态常量更加常用</li>
<li>静态方法：a.不需要访问实例对象的状态，参数显示提供；b.只访问类静态域</li>
<li>静态方法也很适合在工厂中使用</li>
</ul>
<p>##构造器的执行顺序</p>
<ul>
<li>所有数据域初始化为默认值</li>
<li>按顺序执行初始化语句和初始化的块（static构造块只会执行一次，而实例构造块会每创建新对象就执行）</li>
<li>执行构造器</li>
</ul>
<h2 id="析构顺序"><a href="#析构顺序" class="headerlink" title="析构顺序"></a>析构顺序</h2><ul>
<li>finalize()方法，在对象被回收之前调用，永远只会调用一次</li>
<li>可以拯救一次对象不被回收</li>
</ul>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul>
<li>包是为了确保类名的唯一性</li>
<li>使用一个包中的类可以直接使用全类名，也可以使用import语句</li>
<li>静态导入：在import语句加上static就可以使用静态方法而不加前缀，不推荐</li>
<li>只有有了package语句，类才会放入包中，否则只会放入default package</li>
</ul>
<h2 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h2><ul>
<li>JAR是以ZIP形式组织的</li>
<li>为了使某个类能够被程序共享：<ul>
<li>将类放到一个基目录当中/home/user/classdir</li>
<li>将JAR文件放在一个目录中/home/user/archives</li>
<li>设置类路径，以冒号分隔<ul>
<li>java -classpath /home/user/classdir: . :/home/user/archives/archive.jar MyProg</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><ul>
<li>super不同于this，并不能赋值给其他的引用，只是指示编译器调用父类的东西</li>
<li>super也可以调用父类的构造器</li>
</ul>
<h2 id="String-StringBuilder-StringBuffer"><a href="#String-StringBuilder-StringBuffer" class="headerlink" title="String StringBuilder StringBuffer"></a>String StringBuilder StringBuffer</h2><p><strong>String</strong></p>
<ul>
<li>StringBuilder和StringBuffer都是集成AbstractStringBuilder这个抽象类，区别主要是二者的线程安全性</li>
</ul>
<p><strong>AbstractStringBuilder</strong></p>
<ul>
<li>内部一个非final的byte[] value储存数据</li>
<li>很多东西都涉及到一个coder，也就是字符串的编码问题，显然数组的length并不是capacity，这之间还要一个coder作为介质，当length一定的时候那么coder不同具体的count当然是不相同的</li>
</ul>
<p><strong>StringBuilder</strong></p>
<ul>
<li>StringBuilder内部的value数组并不是final，因此是可以扩展的</li>
</ul>
<p><strong>StringBuffer</strong></p>
<ul>
<li>线程安全，append操作加了synchronized</li>
<li>StringBuffer的所有的方法几乎全部上锁，这导致了性能肯定不是很理想</li>
</ul>
<h2 id="Java的异常处理机制"><a href="#Java的异常处理机制" class="headerlink" title="Java的异常处理机制"></a>Java的异常处理机制</h2><ul>
<li>异常时什么？就是指阻止当前方法或作用域继续执行的问题,当程序运行时出现异常时,系统就会自动生成一个Exception对象来通知程序进行相应的处理。</li>
</ul>
<p><strong>Throwable</strong></p>
<ul>
<li><p><strong>Exception</strong></p>
<ul>
<li><p>受检查异常：编译器在编译的时候看，受检查异常必须要try…catch，否则无法编译</p>
<ul>
<li>常见的比如IO、ClassNotFoundException、线程问题</li>
</ul>
</li>
<li><p>运行时异常：RuntimeException</p>
<ul>
<li>NullPointException</li>
<li>NumberFormatException</li>
<li>ClassCastException</li>
</ul>
</li>
<li><p>如果catch不匹配，JVM还是会将异常抛出</p>
</li>
<li><p>如果在当前方法不知道该如何处理该异常时，则可以使用throws对异常进行抛出给调用者处理或者交给JVM。JVM对异常的处理方式是：打印异常的跟踪栈信息并终止程序运行</p>
</li>
<li><p>finally进行清理工作，尽量使资源恢复到初始状态</p>
</li>
<li><p>即使try或者catch中使用了返回语句，finally还是会执行</p>
</li>
<li><p>Java异常丢失问题</p>
<ul>
<li>finally中重写抛出异常，这种异常会覆盖原来的异常</li>
<li>finall中return</li>
</ul>
</li>
<li><p>重新抛出异常以及异常链</p>
<ul>
<li>throws抛出交给上级处理</li>
<li>在catch中不做任何处理，也只是向上抛出，然后通过关键字throws继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链</li>
<li>捕获到异常之后可以覆盖前面的异常，也可以利用这个异常初始化新异常然后抛出，这样会起到caused by的效果</li>
</ul>
</li>
<li><p>Java异常限制</p>
<ul>
<li>子类在重写父类抛出异常的方法时，要么不抛出异常，要么抛出与父类方法相同的异常或该异常的子类</li>
<li>子类在重写父类抛出异常的方法时，如果实现了有相同方法签名的接口且接口中的该方法也有异常声明，则子类重写的方法要么不抛出异常，要么抛出父类中被重写方法声明异常与接口中被实现方法声明异常的交集</li>
</ul>
</li>
<li><p>Java异常与构造器</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//如果构造器都失败了，那么去执行in.dispose()方法不合适</span></span><br><span class="line">    <span class="comment">//可以用嵌套的结构保证构造器的安全</span></span><br><span class="line">    InputFile in=<span class="keyword">new</span> InpputFile(<span class="string">"Cleanup.java"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	String string;</span><br><span class="line">    	<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">while</span> ((string=in.getLine())!=<span class="keyword">null</span>) &#123;&#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    	System.out.println(<span class="string">"Cause Exception in main"</span>);</span><br><span class="line">    	e.printStackTrace(System.out);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    	in.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"InputFile construction failed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Error</strong></p>
</li>
<li><p>异常使用指南</p>
<ul>
<li>在恰当的级别处理异常（在知道如何处理的情况下才捕获异常）</li>
<li>努力解决问题并且重新调用产生异常的方法</li>
<li>进行少许修补，然后绕过异常的地方重新执行</li>
<li>把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层</li>
<li>把当前运行环境下能做的事情尽量做完，然后把不相同的异常重抛到更高层</li>
<li>努力让类库和程序更安全</li>
</ul>
</li>
</ul>
<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java/IO"></a>Java/IO</h2><p><strong>IO（BIO）</strong></p>
<ul>
<li>同步阻塞IO，操作对象是流，一个线程一次最多智能处理一个流的IO请求，否则要使用多线程</li>
<li>流实际上就是一段连续的数据，有字节流和字符流之分</li>
<li>字节流和字符流可以相互转换</li>
<li>字节流<ul>
<li>处理字节或者是二进制数据</li>
<li>InputStream<ul>
<li>FileInputStream</li>
<li>BufferedInputStream</li>
</ul>
</li>
<li>OutputStream<ul>
<li>FileOutputStream</li>
<li>BufferedOutputStream</li>
</ul>
</li>
</ul>
</li>
<li>字符流</li>
<li>处理字符文本或者是字符串<ul>
<li>Reader<ul>
<li>FileReader</li>
<li>BufferedReader</li>
</ul>
</li>
<li>Writer<ul>
<li>FileWriter</li>
<li>BufferedWriter</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>NIO</strong></p>
<ul>
<li>同步非阻塞IO，多路复用IO模型，NIO中的Buffer、Channel、Selector</li>
<li>Buffer是一个对象，它包含一些要写入或者读出的数据，在NIO中所有数据都是用缓存区处理的，在读数据的时候要从缓冲区中读，写数据的时候会先写到缓冲区中，缓冲区本质上是一块可以写入数据，然后可以从中读取数据的一个数组，提供了对数据的结构化访问以及在内部维护了读写位置等信息</li>
<li>Channel（通道），Channel（通道）数据总是从通道读取到缓冲区，或者从缓冲区写入到通道中，Channel只负责运输数据，而操作数据是Buffer</li>
</ul>
<p><strong>AIO</strong></p>
<ul>
<li>异步非阻塞IO</li>
</ul>
<h2 id="Java泛型机制"><a href="#Java泛型机制" class="headerlink" title="Java泛型机制"></a>Java泛型机制</h2><ul>
<li>原来的ArrayList是Object[]实现的，取出的时候要强制转型，而且放入的时候没有检查</li>
</ul>
	
	</div>
	
	<div id="current-post-cover" data-scr="/img/post-cover/pic17.jpg"></div>

	<!-- relate post, comment...-->
	<div class="investment-container">
		<div class="investment-header">
			<div class="investment-title-1">
				<div class="on">Related post</div>
				<div>Comment</div>
				<div>Share</div>
			</div>
			<div class="investment-title-2">	            
				
	<span>
		<a href="javascript: window.scrollTo(0, 0);">To Top</a>
		
			<a href="/2020/06/05/初探Go的RPC实现/" title="初探Go的RPC实现" rel="prev">
				&laquo;Pre post
			</a>
		
		
			<a href="/2020/06/02/GO中的数据类型/" title="GO中的数据类型" rel="next">
				Next post&raquo;
			</a>
			
	</span>


      		
			</div>	
		</div>
		
		<div class="investment-content">
			<div class="investment-content-list">
				

<div class="relate-post">
	
		<ul>
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/11/25/vim_sduty/" title="开始使用vim">
								开始使用vim			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十一月 25日, 2021				
							</p>
							<p class="relate-post-content">
								vim这次真的要下决心使用vim了，当然我用vim其实已经很长时间了，但是都是一些最简单的编辑，往往是到了服务器上没办法了，只有vim可以用才会用vim，从没把vim当成主力编码编辑器。
刚刚毕业上班的时候搞了一个github上面别人...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/11/25/vim_sduty/" title="开始使用vim">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic43.jpg" alt="开始使用vim"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/10/23/c++ coroutine/" title="c++ coroutine">
								c++ coroutine			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十月 23日, 2021				
							</p>
							<p class="relate-post-content">
								c++ coroutinebackground
c++20终于支持了协程，c++实现的是无栈协程，首先还是区分一下有栈协程和无栈协程：

有栈协程：最典型的就是go语言的协程，每一个协程函数都有自己的栈，协程函数在这个栈上运行，一般会...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/10/23/c++ coroutine/" title="c++ coroutine">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic42.jpg" alt="c++ coroutine"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/08/21/tcpdump/" title="tcpdump">
								tcpdump			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								八月 21日, 2021				
							</p>
							<p class="relate-post-content">
								tcpdump1.简介
一个网络抓包工具，可以分析网络的行为、性能和各种应用的流量。开发的时候可能因为复杂的网络需要在测试环境调通，毕竟不是自己倒腾项目一台机器，很容易知道通不通，企业级的环境可能会十分复杂，偶尔可能会用得上tcpdu...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/08/21/tcpdump/" title="tcpdump">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic41.jpg" alt="tcpdump"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/02/26/GO的闭包/" title="GO的闭包">
								GO的闭包			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								二月 26日, 2021				
							</p>
							<p class="relate-post-content">
								GO的闭包background
Golang作为一门新生代的编程语言，在近10年得到了巨大的发展，目前除了像字节跳动这样的以Golang为主要编程语言的公司，还有诸如腾讯、阿里内部也有部分项目开始用Golang编写。
Golang是兼...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/02/26/GO的闭包/" title="GO的闭包">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic38.jpg" alt="GO的闭包"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/02/11/redis二三事（三）/" title="redis二三事（三）">
								redis二三事（三）			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								二月 11日, 2021				
							</p>
							<p class="relate-post-content">
								字典background
我们常常将redis成为一种键值对数据库，这也就是体现了redis的本质，你甚至可以将redis看作是一个大型的哈希表，我们对于redis的操作基本都是利用相关的key去操作相关的value。
如果你想学习过...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/02/11/redis二三事（三）/" title="redis二三事（三）">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic40.jpg" alt="redis二三事（三）"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/01/19/Linux下的线程操作/" title="Linux下的线程操作">
								Linux下的线程操作			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								一月 19日, 2021				
							</p>
							<p class="relate-post-content">
								Linux下的线程background
最近在学c++的时候看到了一些用c++实现web server的项目，觉得很是新奇，这也体现了c++造轮子的能力。
这一层相比我平常做的一些业务逻辑来说更加贴近底层，这么说并非意味着这些是什么很...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/01/19/Linux下的线程操作/" title="Linux下的线程操作">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic37.jpg" alt="Linux下的线程操作"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/01/05/leetcode_4/" title="leetcode_4">
								leetcode_4			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								一月 5日, 2021				
							</p>
							<p class="relate-post-content">
								LeetcodeBackground（题外话）
上一篇刷题的blog已经有60题了，今天再重新开一篇出来记录，刷的题目数量已经超过200了，全站排名也在上升，还是比较有成就感的。
今天的寒假放的很早，人生中的最后一个寒假了。
这个寒假...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/01/05/leetcode_4/" title="leetcode_4">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic29.jpg" alt="leetcode_4"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2020/12/12/demo-for-study/" title="demo for study">
								demo for study			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十二月 12日, 2020				
							</p>
							<p class="relate-post-content">
								Demo for studybackground
在我们日常学习的时候，一个很有效的方式就是自己敲代码，通过实践来不断加深自己的理解。在很多时候，我们刚开始学习一个知识点的时候，一个好方法就是从copy开始，当然这个copy还必须是手...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2020/12/12/demo-for-study/" title="demo for study">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic36.jpg" alt="demo for study"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2020/12/04/redis二三事（二）/" title="redis二三事（二）">
								redis二三事（二）			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十二月 4日, 2020				
							</p>
							<p class="relate-post-content">
								字符串和数字面试的时候常常会被问到redis的数据类型，首当其冲的自然就是string和数字，那么你知道string和数字在redis的底层是怎样实现的吗？
string
要想回答string相关的内容你首先要知道C语言中的一个字符串...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2020/12/04/redis二三事（二）/" title="redis二三事（二）">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic35.jpg" alt="redis二三事（二）"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2020/11/17/redis二三事（一）/" title="redis二三事（一）">
								redis二三事（一）			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十一月 17日, 2020				
							</p>
							<p class="relate-post-content">
								Redisredis是一款非常优秀的开源软件，目前被广泛的应用于缓存、消息中间件等多个领域。Redis完全基于内运行，使用多路复用IO模型，用C语言实现了丰富的数据结构，这些优点使得Redis越来越流行，几乎所有公司的后端都会用到Re...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2020/11/17/redis二三事（一）/" title="redis二三事（一）">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic34.jpg" alt="redis二三事（一）"/>
							</a>
						</div>
					</li>											
			
			
		</ul>
	
</div>	
			</div>
			<div class="investment-content-list">
				<div class="layout-comment">

	

		

			<!-- I don't know !!!-->
			<div>Please check the comment setting in config.yml of hexo-theme-Annie!</div>
			
		
		
	

</div>
			</div>
			<div class="investment-content-list">
				<div class="layout-share">
	
	

		
			
			<!-- socialShare share -->
			<div class="social-share"></div>

<!--  css & js -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
<script async src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
			
		
		
	
</div>


			</div>
		</div>	
	</div>
	</div>
</div>



	<!-- leancloud -->
	<!--
	时间：2018-11-27
	描述：
		文章访问量：visitors
		文章喜欢量：likes	
		文章排行榜：topNPost
		其他得说明：
			01-Cookie相关的函数 
				https://blog.csdn.net/somehow1002/article/details/78511541（Author：somehow1002）
			02-visitors相关的函数 
				https://blog.csdn.net/u013553529/article/details/63357382（Author：爱博客大伯）
				https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html（Author：夏末）
			03-topNPost相关的函数
				https://hoxis.github.io/hexo-next-read-rank.html（Author：hoxis）
			04-likes相关的函数，
				参考了01 & 02进行简单的设计与实现
-->


	


<!-- show math formula -->



	 
	<script src="/plugin/clipboard/clipboard.js"></script>
	<script>
		// Copy code !
	    function codePreprocessing() {
	        $("#article-content .highlight").each(function() {

	            $(this).wrap('<div id="post-code"></div>');

	        })

	        $("#article-content #post-code").each(function() {

	            $(this).prepend('<nav class="copy-nav"><span><i class="code-language"></i></span></nav>');

	        })

	        $("#article-content .copy-nav").each(function() {
	            var temp = $(this).next().attr('class'),
	                language = ((temp.length > 9) && (temp != null)) ? temp.substr(10) : "none"; //why 9? Need to check language?

	            $(this).find('.code-language').text(language);

	            $(this).append('<span class="copy-btn"><i class="fa fa-copy" aria-hidden="true"></i></span>');

	        });
	    }

		function codeCopy() {
		    $('#article-content #post-code').each(function(i) {
		        var codeCopyId = 'codeCopy-' + i;

		        var codeNode = $(this).find('.code'),
		            copyButton = $(this).find('.copy-btn');

		        codeNode.attr('id', codeCopyId);
		        copyButton.attr('data-clipboard-target-id', codeCopyId);
		    })

		    
			var clipboard = new ClipboardJS('.copy-btn', {
					target: function(trigger) {
						return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
					}
		      	});

			//pure js
			function showTooltip(elem, msg) {		   
				elem.setAttribute('aria-label', msg);
				elem.setAttribute('class', 'copy-btn copy-status');
				setTimeout(function() {
					elem.setAttribute('class', 'copy-btn');
				}, 2000);
			}

			clipboard.on('success', function(e) {
			    e.clearSelection();
			    console.info('Action:', e.action);		   
			    console.info('Trigger:', e.trigger);
			    showTooltip(e.trigger, 'Copied!');
			    
			});
			clipboard.on('error', function(e) {
			    console.error('Action:', e.action);
			    console.error('Trigger:', e.trigger);
			});
		

		}

		if ($('.layout-post').length) {
		    codePreprocessing();
		    codeCopy();
		} 
	</script>





<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
<script src="/plugin/fancybox/jquery.fancybox.js"></script>

<script type="text/javascript">
	var titleID = $('.article-title a'),
		imageID = $('.article-content img'),
		videoID = $('.article-content video');

	var postTitle = titleID.text() ? titleID.text() : "No post title!";

	imageID.each(function() {
		var imgPath = $(this).attr('src'),
			imgTitle = $(this).attr('alt') ? $(this).attr('alt') : "No image description!";

		//给每个匹配的<img>元素打包, 即添加父元素<a>
		$(this).wrap('<a data-fancybox="gallery" data-caption=" 《 ' + postTitle + ' 》 ' + imgTitle + ' "  href=" ' + imgPath + ' "> </a>');
	});

	videoID.each(function() {
		var videoPath = $(this).attr('src');

		//给每个匹配的<img>元素打包, 即添加父元素<a>
		$(this).wrap('<a data-fancybox href=" ' + videoPath + ' "> </a>');
	});
	//TODO：支持html5 video

	if($('#layout-post').length) {
		$('[data-fancybox="gallery"]').fancybox({
			loop: true,
			buttons: [
				"zoom",
				"share",
				"slideShow",
				"fullScreen",
				//"download",
				"thumbs",
				"close"
			],
			protect: false
		});
	}
</script>
		</main>

		<!--footer-->
		<footer>
	<div class="social">
		<ul>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-github"></i>
			</a>
		</li>
	
		<li>
			<a href="https://weibo.com/5809441156/profile?rightmod=1&wvr=6&mod=personnumber&is_all=1" target="_blank">
				<i class="fa fa-weibo"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-pinterest"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-instagram"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-twitter"></i>
			</a>
		</li>
	
		<li>
			<a href="/atom.xml" target="_blank">
				<i class="fa fa-rss"></i>
			</a>
		</li>
			
</ul>

	</div>
		
	<div class="copyright">
		<p>
			 
				&copy;2017 - 2021, content by Sweet Coder. All Rights Reserved.
			
			
			

	<!-- busuanzi -->
	<!-- busuanzi -->

		
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	

		<span id="busuanzi_container_page_pv">
	  		本文总阅读量<span id="busuanzi_value_page_pv"></span>次
		</span>

	




		</p>
		<p>
			<a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay.
			<a href="javascript:zh_tran('s');" class="zh_click" id="zh_click_s">简体</a> 
			<a href="javascript:zh_tran('t');" class="zh_click" id="zh_click_t">繁體</a>				
		</p>
	</div>		
</footer>
		
	<!-- set '1' to show motto in all pages! -->

	<script src="/plugin/motto/motto.js"></script>
	
	<script type="text/javascript">
		$(".motto").html( getMingYanContent() );
	</script>	





<!-- love effect -->

	<script src="/plugin/love/love.js"></script>


<!-- back to top -->

	
	<div id="totop">
  		<a href="javascript:;"  name="TOTOP" class="fa fa-arrow-up" ></a>
	</div>




<!-- site analysis -->


	<!-- site-analysis -->
	
	
	
	
	
 

<script src="/plugin/vibrant/vibrant.js"></script>
<script src="/plugin/chinese/chinese.js"></script>
<script src="/plugin/imgLazyLoader/yall.min.js"></script>
<script src="/plugin/imgResize/jquery.resizeimagetoparent.min.js"></script>
<script src="/plugin/nicescroll/jquery.nicescroll.js"></script>
<script src="/js/resizediv.js"></script>
<script src="/js/main.js"></script>
	</body>	
</html>