<!--
	作者：Sariay
	时间：2018-09-25
	描述：There may be a bug, but don't worry, QiLing(器灵) says that it can work normally!
-->
<!DOCTYPE html>
<html class="html-loading">
		

<head><meta name="generator" content="Hexo 3.9.0">
	<meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <title>
    
      漫谈AQS | Sweet Blog
    
  </title>
  <meta name="author" content="Sweet Coder">
  <meta name="keywords" content>
  <meta name="description" content>
	<!-- favicon -->
  <link rel="shortcut icon" href="/img/favicon.ico">

  <!-- css -->
  <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/Annie.css">
  
  <!-- jquery -->
	<script src="/js/jquery.min.js"></script>

  <!-- leancloud -->
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
<script src="/js/leancloud.js"></script>
</head>
	<body>
		<!-- Preloader -->

	<div id="preloader">
		<div class="pre-container">
			
				<div class="spinner">
					<div class="double-bounce1"></div>
					<div class="double-bounce2"></div>
				</div>
						
		</div>
	</div>


<!-- header -->
<header class="fixbackground" data-img-mode="random" data-normal-src="/" data-random-max="7" data-random-src="/img/Random_img/">
	<div class="mask">
		<!-- Logo and navigation -->
		<div class="h-header">
			<div id="logo">
				<a href="/">
						
						<img src="/img/Signature.png" alt="Logo">
					
				</a>
			</div>
			
			<div id="navigation-show">
				<ul>
	
		<li class="menu-主页">
			<a href="/" class="menu-item-主页">主页</a>
		</li>
	
		<li class="menu-归档">
			<a href="/archives" class="menu-item-归档">归档</a>
		</li>
	
		<li class="menu-分类">
			<a href="/categories" class="menu-item-分类">分类</a>
		</li>
	
		<li class="menu-标签">
			<a href="/tags" class="menu-item-标签">标签</a>
		</li>
	
		<li class="menu-关于">
			<a href="/about" class="menu-item-关于">关于</a>
		</li>
	
		<li class="menu-相册">
			<a href="/gallery" class="menu-item-相册">相册</a>
		</li>
	

	
</ul>
			</div>				
		</div>

		<!-- motto -->
		<div class="h-body">	
			
				<p class="motto"></p>
			
		</div>
		
		<!-- others: such as time... -->			
		<div class="h-footer">
			<a href="javascript:;" id="read-more"><i class="fa fa-angle-double-down" aria-hidden="true"></i>
			</a>

			
				<!-- 
	This is only a demo, please go to "https://time.is" to set your city time! 
-->
<style type="text/css">
	.header-date {
		font-size: 1.6rem;
		color: #fff;
		position: absolute;
		bottom: 5px;
		right: 1rem;
		writing-mode: tb-rl;
	}	
	
	.header-date a {
		border-bottom: none;
	}

	@media only screen and (max-width: 768 ) {
		.header-date {
			font-size: 1rem;
		}			
	}
</style>
<div class="header-date">
	<a href="https://time.is/Beijing" id="time_is_link" rel="nofollow" ></a>
	<span id="Beijing_z43d"></span>
</div>
<script src="//widget.time.is/zh.js"></script>
<script>
	time_is_widget.init({
		Beijing_z43d:{
			template:"DATE", 
			date_format:"year年 monthname dnum日"
		}
	});
</script>
			
		</div>
	</div>
</header>

<div id="navigation-hide">
	<!-- Progress bar -->
	<div id="progress-bar"></div>

	<!-- Progress percent -->
	<div id="progress-percentage"><h1>0.0%</h1></div>

	<div class="toc-switch"><span class="switch-button">Catalog</span></div>

	<!-- Page title -->
	<p>
		
			Current post&nbsp;:&nbsp;《漫谈AQS》
		
	</p>

	<!-- Nav trigger for navigation-H-->
	<a class="nav-trigger"><span></span></a>
</div>

<!-- Navigation in div(id="navigation-H") -->
<nav class="nav-container" id="cd-nav">
	<div class="nav-header">
		<h3>Navigation</h3>
		<a href="javascript:;" class="nav-close"></a>
	</div>
	<div class="nav-body">
		<ul>
	
		<li class="menu-主页">
			<a href="/" class="menu-item-主页">主页</a>
		</li>
	
		<li class="menu-归档">
			<a href="/archives" class="menu-item-归档">归档</a>
		</li>
	
		<li class="menu-分类">
			<a href="/categories" class="menu-item-分类">分类</a>
		</li>
	
		<li class="menu-标签">
			<a href="/tags" class="menu-item-标签">标签</a>
		</li>
	
		<li class="menu-关于">
			<a href="/about" class="menu-item-关于">关于</a>
		</li>
	
		<li class="menu-相册">
			<a href="/gallery" class="menu-item-相册">相册</a>
		</li>
	

	
</ul>
	</div>
	<div class="nav-footer">
		<ul>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-github"></i>
			</a>
		</li>
	
		<li>
			<a href="https://weibo.com/5809441156/profile?rightmod=1&wvr=6&mod=personnumber&is_all=1" target="_blank">
				<i class="fa fa-weibo"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-pinterest"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-instagram"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-twitter"></i>
			</a>
		</li>
	
		<li>
			<a href="/atom.xml" target="_blank">
				<i class="fa fa-rss"></i>
			</a>
		</li>
			
</ul>

	</div>
</nav>
			
		<!--main-->
		<main>
			<!--
	时间：2018-11-17
	描述：
		插件名称：katelog.min.js
		插件作者：KELEN
		插件来源: https://github.com/KELEN/katelog
-->

	
		<div class="layout-toc">
			<div id="layout-toc">
				<div class="k-catelog-list" id="catelog-list" data-title="文章目录"></div>
			</div>
		</div>

		
		<script src="/plugin/toc/katelog.min.js"></script>

		
	 

<div class="layout-post">
	<div id="layout-post">
	<div class="article-title">
		<i class="fa fa-paper-plane-o" aria-hidden="true"></i>
		
	<a href="/2020/08/26/漫谈AQS/" itemprop="url">
		漫谈AQS
	</a>

	</div>

	<div class="article-meta">
		<span>
			<i class="fa fa-calendar"></i>
			


	Posted on

	<a href="/2020/08/26/漫谈AQS/" itemprop="url">
		<time datetime="2020-08-26T12:05:31.000Z" itemprop="datePublished">
	  		2020-08-26
	  </time>
	</a>
	&nbsp;





			




	Updated on

	<a href="/2020/08/26/漫谈AQS/" itemprop="url">
		<time datetime="2020-08-26T12:05:31.000Z" itemprop="dateUpdated">
	  		2020-09-20
	  </time>
	</a> 



		</span>
		<span>
			<i class="fa fa-tags"></i>
			
	
		<a href="/tags/Java/" class=" ">
			Java
		</a>
	
		<a href="/tags/AQS/" class=" ">
			AQS
		</a>
	
		
		</span>
		
		



	</div>

	<div class="article-content" id="article-content">
		<h3 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h3><p>实习回来又要投入到秋招的浪潮当中，虽然本人目前是更加倾向于GO方面的岗位，但是也深知自己对GO的理解可能还是不够深入，Java的岗位自己也是想去尝试一下。</p>
<p>因为之前一直是准备Java来着，所以其实Java的基础还在，只是需要尽快复习捡起来。但是一些基础的知识就是快速的过一遍，经典的技术点就写一下博客记录一下，之前可能有些东西一直没有弄明白，过了这么长时间再去回顾一下。</p>
<p>因为之前一直很害怕关于并发的东西，这一次就从Java中的AQS开始，希望能够有更深入的理解！</p>
<p><strong>background</strong></p>
<p>只要提到Java的并发，一定少了AQS（抽象队列同步器）这个话题。AQS使用一个队列帮我们完成了多个线程在竞争的时候的处理方法，进程如何获取资源以及如何释放都做了很详细的规定。</p>
<p>AQS作为一个抽象类，本身就是用于帮助我们构建各种同步工具（这也是抽象类和接口的不同使用场景，抽象类可以定义更多的东西，开发人员可以很简单的通过继承抽象类来实现相应的功能，而接口必须要开发人员实现所有的方法才可以）。在AQS的基础上我们可以实现<strong>Lock</strong>、<strong>Mutex</strong>、<strong>CountDownLatch</strong>等各种各样的同步工具，最出名的应当就是我们常用的<strong>ReentrantLock</strong>。</p>
<p>AQS的本质就是一个队列，线程需要争夺临界资源的时候需要进行入队。这个队列的思想其实并不是AQS的原创，这个队列的成为<strong>CLH</strong>（Craig，Landin， Hagersten），但是AQS还是对CLH做了一定的改进，具体的实现我们后面会写到。</p>
<p>其实并发是所有操作语言中都很重要的一部分，只是Java中一般会问的比较多，在简单的同步工具使用之后面试官一般就会问到AQS这个东西，如果我们能够对AQS有自己的理解，会很有优势。当然，理解AQS并不代表我们理解了整个并发的场景，我个人在面试的时候是比较怕面试官问一些具体的并发场景的，这玩意儿说实话没有实战经验确实很难有什么很深入的见解，所以我们还是先把一些原理性的知识搞清楚，以后在上手并发的时候也能更快！</p>
<h3 id="CLH"><a href="#CLH" class="headerlink" title="CLH"></a>CLH</h3><p><strong>CLH</strong>：CLH是一个用于同步的队列，本质是一个自旋锁，能够确保线程不会出现饥饿，并且因为是用队列实现的，保证先来先服务的公平性。</p>
<p>举一个简单的例子：false(head) &lt;- true(current thread) &lt;- true &lt;- true &lt;- true(tail)</p>
<p>这样的一个队列中，每次只有head之后的那一个节点可以成功的获取到锁，之后的节点都会陷入自旋，显然如果我们需要入队的话就要通过原子操作对tail进行修改，出队的话就很简单，只需要将节点剔除即可，但是这里因为只存了前置节点，剔除操作并不简单，所以直接将本线程的节点设为head即可。剔除之后的对列为false(current thread) &lt;- true &lt;- true &lt;- true(tail)！</p>
<p>来看一下一个具体的实现吧！</p>
<p><strong>MyClhSynchronizer</strong>实现了队列，lock和unLock分别代表了入队和出队操作，可以仔细的看一下，为什么说CLH是一种隐式的链表呢？因为CLH的队列是结合ThreadLocal完成的，curNode（当前线程节点）和prevNode（前置线程节点）都是有线程本地储存的，没有显示在MyClhSynchronizer中存储一条链表，各个线程之间的关系是隐含的。</p>
<p>这里用了ThreadLocal的作用是保证每一个线程都会有一个自己的Node和前置Node，不会相互干扰。当然其实也可以将Node链表存在MyClhSynchronizer中统一处理，但是会比较复杂，AQS就是这样处理的！</p>
<p><strong>tips</strong>：这个代码你肯定不能直接拿去运行，因为Lock接口还有其它的方法，因为我这边没有实现，所以删掉了，你在copy代码过去的时候必须要对那些方法搞一个默认的实现才行！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClhSynchronizer</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Node&gt; tail;</span><br><span class="line">    <span class="comment">// 这两个玩意儿为啥要用ThreadLocal呢？</span></span><br><span class="line">    <span class="comment">// 很容易理解，没有线程都会有自己的curNode（表示当前线程占领的Node），也会有前置Node</span></span><br><span class="line">    <span class="comment">// 没有线程的curNode和prevNode都是私有的，并不相同</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Node&gt; curNode;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Node&gt; prevNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个线程有一个Node节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> locked;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.locked = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocked</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.locked = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.locked;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClhSynchronizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化同步器的线程默认是头结点</span></span><br><span class="line">        <span class="comment">// CLH是在前置的Node上进行自旋，那么头结点必然是永远不上锁，locked设为false</span></span><br><span class="line">        <span class="comment">// 此时初始化了一个tail，这个Node相当于整个队列的头结点，locked永远为false</span></span><br><span class="line">        tail = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="keyword">new</span> Node());</span><br><span class="line">        <span class="comment">// 获取一个新的Node，充当当前线程的代表，默认初始化为不上锁</span></span><br><span class="line">        curNode = <span class="keyword">new</span> ThreadLocal&lt;Node&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Node <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 注意，返回的初始化Node永远是locked=false，在Lock中可以进行操作</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Node();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ThreadLocal返回的前置Node并没有相关的值，我们需要获取尾结点然后注入进去</span></span><br><span class="line">        prevNode = <span class="keyword">new</span> ThreadLocal&lt;Node&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Node <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 整个Lock的过程实际上特别简单</span></span><br><span class="line">        <span class="comment">// 创建一个代表本线程的Node</span></span><br><span class="line">        Node cur = <span class="keyword">this</span>.curNode.get();</span><br><span class="line">        <span class="comment">// 状态设为需要锁</span></span><br><span class="line">        cur.setLocked(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 将这个节点接入队列，并获取之前的tail节点，旧的tail节点充当本节点的前置节点</span></span><br><span class="line">        Node oldTail = <span class="keyword">this</span>.tail.getAndSet(cur);</span><br><span class="line">        <span class="keyword">this</span>.prevNode.set(oldTail);</span><br><span class="line">        <span class="keyword">while</span> (oldTail.getLocked()) &#123;</span><br><span class="line">            <span class="comment">// 如果前置线程不释放锁，那么就一直自旋等待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 解锁很简单</span></span><br><span class="line">        Node cur = <span class="keyword">this</span>.curNode.get();</span><br><span class="line">        cur.setLocked(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 稍微解释一下，加入现在有如下这个队列</span></span><br><span class="line">        <span class="comment">// false（head） &lt;- true &lt;- true &lt;- true（tail），此时必然只有第二个节点拥有了锁</span></span><br><span class="line">        <span class="comment">// 如果这个线程执行完毕，需要键节点从队列中剔除，但是不能影响后面的节点，只要用头结点来替换本线程的节点就可以了</span></span><br><span class="line">        <span class="keyword">this</span>.curNode.set(<span class="keyword">this</span>.prevNode.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说了这么多，这玩意儿到底管不管用呢？测试一下就知道了，我们还是利用对一个int数字进行加操作，我们开启20个线程，每个线程对数字进行10000次add操作，最后的理想结果应该是200000！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock myLock = <span class="keyword">new</span> MyClhSynchronizer();</span><br><span class="line">        CountDownLatch count = <span class="keyword">new</span> CountDownLatch(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10000</span>; k++) &#123;</span><br><span class="line">                    myLock.lock();     <span class="comment">// 测试无锁状态时去掉本行</span></span><br><span class="line">                    add();</span><br><span class="line">                    myLock.unlock();   <span class="comment">// 测试无锁状态时去掉本行</span></span><br><span class="line">                &#125;</span><br><span class="line">                count.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了对比测试，在测试无锁的时候只需要将myLock.lock()、myLock.unLock()去掉即可。经过多次测试，在加锁的状态下，结果为200000，正确。在不加锁的状态下，结果不确定，但是都小于200000。这也说明我们实现的这个CLH锁是有效的！</p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p><strong>AQS</strong>：AQS的CLH并不是上面这样的标准CLH，AQS对CLH进行了改进。如果大家对上述的代码自己去写一下的话就会发现CLH的前置单链表形式对我们的操作有很大影响，所以在AQS中单链表形式被改进为双链表。</p>
<p>并且AQS对队列的规定是，enqueue需要对tail进行原子操作保证正确性，dequeue只需要设置head节点就可以。因为在AQS的内部是支持多个线程并发入队的，但是出队的时候必然只能一个一个的同步出队，因此dequeue操作并没有任何同步措施。</p>
<p><strong>AQS Node</strong>：Node代表线程在队列中进行排队的情况，Node中存放着相关的线程，以及线程的状态等等。其中，Node中比较重要的包括以下内容：</p>
<ul>
<li>int waitStatus：表示该Node中现成的状态，主要包括五种状态：<ul>
<li>CANCLLED = 1：表示本线程已经撤销，可能原因包括超时或者是中断</li>
<li>SIGNAL = -1：表示当前节点线程结束之后需要主动唤醒后置节点，这是互斥锁必须的</li>
<li>CONDITION = -2：当前线程在等待一个条件</li>
<li>PROPAGATE = -3：当前线程处于传播态，在共享模式之下，共享锁的状态可以传播</li>
<li>0：none of the above</li>
</ul>
</li>
<li>Node prev：前置节点</li>
<li>Node next：后置节点 </li>
<li>Thread thread：当前节点的线程</li>
<li>Node nextwaiter：用于条件等待的节点，或者是表示后置节点是共享等待，如果为null则表示互斥等待</li>
<li>Node head：同步队列的头结点</li>
<li>Node tail：同步队列的尾结点</li>
<li>int state：同步状态</li>
</ul>
<h3 id="AQS队列相关的重要操作"><a href="#AQS队列相关的重要操作" class="headerlink" title="AQS队列相关的重要操作"></a>AQS队列相关的重要操作</h3><p>对于AQS队列的操作是整个AQS的灵魂，也是其中最复杂的地方，但是我们还是先看懂一些简单的操作然后将整个操作串起来，最后再整体理解AQS的队列操作。其实我们可以发现，每一个单个的操作其实都不是很复杂，go!</p>
<p><strong>1.enq</strong></p>
<p>入队操作，如果临界资源被占领，新进来的线程是会被放进一个Node节点，然后将该Node放入到队列中，这里主要是尾部插入，涉及到对tail的同步操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这是一个自旋操作，会直到入队成功</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">// 延迟初始化，注意这个head节点初始化之后是不会用来防止线程的，仅仅是充当整个队列的头</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// 利用cas操作设置tail，保证并发正确性</span></span><br><span class="line">            <span class="comment">// 注意到这里的双向链表在多个线程入队的时候可能出现线面的情况</span></span><br><span class="line">            <span class="comment">// head &lt;-&gt; ndoe &lt;-&gt; node &lt;- node &lt;- node &lt;- node(tail)，prev会比next先设置</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enq的操作其实很简单，就是通过一个CAS进行Node节点的入队操作！</p>
<p><strong>2.addWaiter</strong></p>
<p>添加一个线程入队，上面的enq是一个Node节点的入队，这个函数实际是将线程封装为Node然后入队，并且可以规定线程等待的模式（<strong>mode</strong>），主要是通过mode来设置线程是共享等待还是互斥等待，这个操作仅仅是一层封装，比较简单！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 封装当前的线程</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 首先会尝试直接入队，失败之后再去enq中循环入队</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.setHead</strong></p>
<p>设置队列的head节点，这个操作真的是很简单，因为我们之前就说过在AQS中Node节点出队是一个一个的操作的，不会出现同时出队的情况。一般而言，出对的节点就是队列的head节点之后的那个节点。</p>
<p>这里提一点，我们在看一个函数的时候一定要看这个函数在哪里调用，这里我说setHead函数不需要同步，大家可以看看源码里面哪些地方调用了setHead，想一下为什么不需要同步操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新设置新的head节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.unparkSuccessor</strong></p>
<p>这个函数适用于一个Node节点中的线程执行完成之后唤醒后续的线程，所以队列中中的线程是一个接着一个的执行的，所以说这是一种公平服务。</p>
<p>这里事先提了一下公平，大家肯定知道基于AQS实现的Reentantlock可以实现非公平的锁，这是因为在非公平的时候可能会直接去试着抢占资源，并没有进入队列等待，之后进入了对列的线程之间才是公平的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// waitStatus &lt; 0 表明是有意义的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 为什么取出node的后置节点之后需要这么操作呢？</span></span><br><span class="line">    <span class="comment">// 还记得我前面说的在并发入队时候的情况吗？</span></span><br><span class="line">    <span class="comment">// head &lt;-&gt; ndoe &lt;-&gt; node &lt;- node &lt;- node &lt;- node(tail)，prev会比next先设置</span></span><br><span class="line">    <span class="comment">// 此时会出现节点的后置节点未设置的情况，需要从后之前遍历</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// unpark是将线程唤醒</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实整体看下来这个函数也并不难，只是唤醒一个节点的后置节点，前提是你要搞清楚入队可能会出现的中间态，才能明白为啥需要从后至前遍历！</p>
<p><strong>5.doReleaseShared</strong></p>
<p>这个函数用于共享状态的资源释放，也就是节点的出队操作。你可以试着类比一下读写锁的相关原理和操作！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 还记得SIGNAL的含义吗？下一个节点需要主动唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 这可不是唤醒h，是唤醒h之后的那一个节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果ws == 0说明下一个节点不需要唤醒，要把head状态置为传播态</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.setHeadAndPropagate</strong></p>
<p>这是头结点和传播态，这里的设置传播态是有一定的条件的（我根据官方文档列举一下）：</p>
<ul>
<li>caller主动要求传播（propagate参数）</li>
<li>传播态已经被之前的操作设置在旧的head中，h.waitStatus参数小于0</li>
<li>或者是setHead期间head参数被设置了</li>
</ul>
<p>满足以上三种状态还必须要下一个节点是共享等待的状态才行，如果为null表示我们不知道下一个节点的状态我们也要试一下（对应并发入队的不确定性）。</p>
<p>这里以读写锁举个例子：</p>
<p>head &lt;-&gt; read &lt;-&gt; read &lt;-&gt; write(tail)</p>
<p>显然我们如果对第一个read节点进行<strong>setHeadAndPropagate</strong>操作就可以让第二个read快速获取锁，但是如果第二个read是一个write就没必要进行<strong>doReleaseShared</strong>，因为读写不是共享的。s == null是因为第一个read到第二个read直接的next不一定设置了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7.acquireQueued</strong></p>
<p>在队列中以互斥的方式获取资源，我们看一下这里的相关操作。我们知道一个队列中的Node中的线程肯定是要不断地去尝试获取资源，如果获取到了就去执行，在CLH中如果没有获取到就需要自旋等待，但是像CLH那样所有的线程都在自旋的话对CPU的兴能是一个很大的损耗。</p>
<p>我们来看看AQS是如何改善相关这个缺陷的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 记录线程有没有被中断</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 资源的获取其实也是一个循环操作，知道获取成功</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 显然只有节点的前置节点是head的时候才有资格获取资源，这就是我们说的最多只有一个节点在出队</span></span><br><span class="line">            <span class="comment">// 并且出队是公平的</span></span><br><span class="line">            <span class="comment">// tryAcquire是获取资源的函数，需要我们自己设置</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 重置头结点，这里只能有一个线程在操作，自然不需要同步</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// acquire获取失败之后就要休眠</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们能够知道<strong>shouldParkAfterFailedAcquire</strong>和<strong>parkAndCheckInterrup</strong>的行为就能知道线程获取资源失败之后是个什么行为，ok，那就继续向下看吧！</p>
<p><strong>8.shouldParkAfterFailedAcquire</strong></p>
<p>shouldParkAfterFailedAcquire函数实质上就是决定在这一次获取之后需不需要让线程进入睡眠状态节约CPU的资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">// 前面节点的线程已经知道结束的时候来叫醒我，当然可以去睡大觉了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 前一个节点的线程已经撤销，将这样的线程从队列中剔除</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将前置节点置为SIGNAL状态，这并不会让线程直接休眠，还会继续尝试获取一次</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>9.parkAndCheckInterrupt</strong></p>
<p>parkAndCheckInterrupt函数就很简单了，让线程去休眠，并且返回线程有没有被中断！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里一个在队列中的线程如何获取锁已经比较清楚了：</p>
<ol>
<li>看自己是不是head之后的那一个节点，只有那个节点才有资格</li>
<li>如果是尝试获取资源</li>
<li>如果不是需要设置一下前置节点的状态（让它执行完了之后叫醒自己）</li>
<li>最后就可以睡大觉去了</li>
</ol>
<p><strong>10.doAcquireShared</strong></p>
<p>尝试在共享状态下获取锁，上述那个是互斥状态之下获取锁，来看一下有什么不同（其实大同小异）！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 以共享方式获取锁</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 剩余共享资源大于0，说明可以获取</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 置节点为head并且传播，r是剩余的资源，还记得为什么上面的propagate参数大于0就释放一次吗？</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有什么不同</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实唯一的操作就是这里我们在获取共享锁之后在setHeadAndPropagate中会进行一次节点的释放，这样就能有后续的节点来获取共享锁，例如如果是一个read节点持有锁5，后面的read节点应该也能获取到锁！</p>
<p>之所以互斥锁中没有这一步是因为互斥锁必须要在unlock的时候才能释放节点！</p>
<p><strong>11.acquire</strong></p>
<p>acquire就是正牌的互斥资源获取函数了，如果获取失败就要入队，来看看这些操作！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryAcquire 首先尝试获取资源，成功线程就直接执行</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">// addWaiter(Node.EXCLUSIVE) 将相乘放入互斥的节点进入队列，具体看看上述的addWaiter解析</span></span><br><span class="line">        <span class="comment">// acquireQueued 节点不断地尝试获取资源，直到成功</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都到这一步了，显然这一步操作也不难理解，需要说一句的是这里其实用到了<strong><em>&amp;&amp;</em></strong>的短路特性，用的是如此自然优雅，想一想如果是我们会不会写出if-else呢？在并发包中有很多这样的操作，这是<strong><em>Doug Lea</em></strong>的个人风格！</p>
<p><strong>12.release</strong></p>
<p>release的作用是释放互斥的资源，也就是我们释放锁需要调用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 显然互斥释放没什么难点，释放之后唤醒下一个节点即可</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>13.acquireShared</strong></p>
<p>acquireShared函数用于共享状态之下的获取，如果获取失败，要利用doAcquireShared函数去循环获取，上面已经解释过了，不在重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>14.releaseShared</strong></p>
<p>releaseShared首先尝试释放资源，成功之后还要调用doReleaseShared，还是那个问题，共享锁释放之后就可能给后续的线程腾出位置，<strong>doReleaseShared</strong>可以加快后续线程获取锁的速度！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>summary</strong></p>
<p>到这里AQS中的主要内容基本说了一大半，还有一些细节大家可能就要自己去看一下源码了！这里try开头的函数是需要我们自己去定义的，我们根据自己需要实现的同步工具来制定获取的规则。</p>
<p>如果大家想看一下具体的实现，推荐去看一下Reetrantlock是怎么实现互斥锁和共享锁的。AQS给我们通过队列制定了一个很好的同步规则，剩余的同步工具其实很好实现，希望对大家有所帮助，也希望自己之后面试被问到AQS不会一无所知！</p>
<p>这也是回家之后的第一篇博客，希望可以把这个实习期间养成的习惯坚持下去！！！</p>
<p>2020.08.26 20:04</p>
	
	</div>
	
	<div id="current-post-cover" data-scr="/img/post-cover/pic30.jpg"></div>

	<!-- relate post, comment...-->
	<div class="investment-container">
		<div class="investment-header">
			<div class="investment-title-1">
				<div class="on">Related post</div>
				<div>Comment</div>
				<div>Share</div>
			</div>
			<div class="investment-title-2">	            
				
	<span>
		<a href="javascript: window.scrollTo(0, 0);">To Top</a>
		
			<a href="/2020/08/28/漫谈http/" title="漫谈http" rel="prev">
				&laquo;Pre post
			</a>
		
		
			<a href="/2020/08/24/leetcode_2/" title="Leetcode_2" rel="next">
				Next post&raquo;
			</a>
			
	</span>


      		
			</div>	
		</div>
		
		<div class="investment-content">
			<div class="investment-content-list">
				

<div class="relate-post">
	
		<ul>
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/02/26/GO的闭包/" title="GO的闭包">
								GO的闭包			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								二月 26日, 2021				
							</p>
							<p class="relate-post-content">
								GO的闭包background
Golang作为一门新生代的编程语言，在近10年得到了巨大的发展，目前除了像字节跳动这样的以Golang为主要编程语言的公司，还有诸如腾讯、阿里内部也有部分项目开始用Golang编写。
Golang是兼...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/02/26/GO的闭包/" title="GO的闭包">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic38.jpg" alt="GO的闭包"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/02/11/redis二三事（三）/" title="redis二三事（三）">
								redis二三事（三）			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								二月 11日, 2021				
							</p>
							<p class="relate-post-content">
								字典background
我们常常将redis成为一种键值对数据库，这也就是体现了redis的本质，你甚至可以将redis看作是一个大型的哈希表，我们对于redis的操作基本都是利用相关的key去操作相关的value。
如果你想学习过...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/02/11/redis二三事（三）/" title="redis二三事（三）">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic40.jpg" alt="redis二三事（三）"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/01/19/Linux下的线程操作/" title="Linux下的线程操作">
								Linux下的线程操作			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								一月 19日, 2021				
							</p>
							<p class="relate-post-content">
								Linux下的线程background
最近在学c++的时候看到了一些用c++实现web server的项目，觉得很是新奇，这也体现了c++造轮子的能力。
这一层相比我平常做的一些业务逻辑来说更加贴近底层，这么说并非意味着这些是什么很...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/01/19/Linux下的线程操作/" title="Linux下的线程操作">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic37.jpg" alt="Linux下的线程操作"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2021/01/05/leetcode_4/" title="leetcode_4">
								leetcode_4			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								一月 5日, 2021				
							</p>
							<p class="relate-post-content">
								LeetcodeBackground（题外话）
上一篇刷题的blog已经有60题了，今天再重新开一篇出来记录，刷的题目数量已经超过200了，全站排名也在上升，还是比较有成就感的。
今天的寒假放的很早，人生中的最后一个寒假了。
这个寒假...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2021/01/05/leetcode_4/" title="leetcode_4">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic29.jpg" alt="leetcode_4"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2020/12/12/demo-for-study/" title="demo for study">
								demo for study			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十二月 12日, 2020				
							</p>
							<p class="relate-post-content">
								Demo for studybackground
在我们日常学习的时候，一个很有效的方式就是自己敲代码，通过实践来不断加深自己的理解。在很多时候，我们刚开始学习一个知识点的时候，一个好方法就是从copy开始，当然这个copy还必须是手...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2020/12/12/demo-for-study/" title="demo for study">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic36.jpg" alt="demo for study"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2020/12/04/redis二三事（二）/" title="redis二三事（二）">
								redis二三事（二）			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十二月 4日, 2020				
							</p>
							<p class="relate-post-content">
								字符串和数字面试的时候常常会被问到redis的数据类型，首当其冲的自然就是string和数字，那么你知道string和数字在redis的底层是怎样实现的吗？
string
要想回答string相关的内容你首先要知道C语言中的一个字符串...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2020/12/04/redis二三事（二）/" title="redis二三事（二）">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic35.jpg" alt="redis二三事（二）"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2020/11/17/redis二三事（一）/" title="redis二三事（一）">
								redis二三事（一）			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十一月 17日, 2020				
							</p>
							<p class="relate-post-content">
								Redisredis是一款非常优秀的开源软件，目前被广泛的应用于缓存、消息中间件等多个领域。Redis完全基于内运行，使用多路复用IO模型，用C语言实现了丰富的数据结构，这些优点使得Redis越来越流行，几乎所有公司的后端都会用到Re...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2020/11/17/redis二三事（一）/" title="redis二三事（一）">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic34.jpg" alt="redis二三事（一）"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2020/11/04/c++实现经典数据结构/" title="c++实现经典数据结构">
								c++实现经典数据结构			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十一月 4日, 2020				
							</p>
							<p class="relate-post-content">
								Data Structure(c++)因为确定这次秋招是去到鹅厂，微信的技术栈还是以c++为主，所以最近也是一直在学习c++，俗话说得好实践是检验真理的唯一标准。c++这门语言本身的特点就是语法十分繁杂，整个语言包含的东西十分的广泛，...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2020/11/04/c++实现经典数据结构/" title="c++实现经典数据结构">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic33.jpg" alt="c++实现经典数据结构"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2020/10/12/leetcode_3/" title="leetcode_3">
								leetcode_3			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十月 12日, 2020				
							</p>
							<p class="relate-post-content">
								LeetcodeBackground（题外话）
艰难的秋招终于结束了，比较幸运，虽然秋招开始的很晚，自己一度以为大厂hc所剩无几，准备好去小厂了，但是最终还是收获了腾讯wxg的录用意向。
秋招一路走来其实并不顺利，中间遇到了很多困难，...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2020/10/12/leetcode_3/" title="leetcode_3">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic29.jpg" alt="leetcode_3"/>
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2020/08/30/Interview/" title="Interview">
								Interview			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								八月 30日, 2020				
							</p>
							<p class="relate-post-content">
								面试常见问题秋招每天都会复习很多的知识点，顺便也整理一下复习过的东西，希望映像更加深刻一点！
说实话这样复习是很消耗时间和精力的，需要我们有耐心，同时也要有信心去面对各种各样的问题！
Redis1.redis为什么快
redis作为常...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2020/08/30/Interview/" title="Interview">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/pic32.jpg" alt="Interview"/>
							</a>
						</div>
					</li>											
			
			
		</ul>
	
</div>	
			</div>
			<div class="investment-content-list">
				<div class="layout-comment">

	

		

			<!-- I don't know !!!-->
			<div>Please check the comment setting in config.yml of hexo-theme-Annie!</div>
			
		
		
	

</div>
			</div>
			<div class="investment-content-list">
				<div class="layout-share">
	
	

		
			
			<!-- socialShare share -->
			<div class="social-share"></div>

<!--  css & js -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
<script async src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
			
		
		
	
</div>


			</div>
		</div>	
	</div>
	</div>
</div>



	<!-- leancloud -->
	<!--
	时间：2018-11-27
	描述：
		文章访问量：visitors
		文章喜欢量：likes	
		文章排行榜：topNPost
		其他得说明：
			01-Cookie相关的函数 
				https://blog.csdn.net/somehow1002/article/details/78511541（Author：somehow1002）
			02-visitors相关的函数 
				https://blog.csdn.net/u013553529/article/details/63357382（Author：爱博客大伯）
				https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html（Author：夏末）
			03-topNPost相关的函数
				https://hoxis.github.io/hexo-next-read-rank.html（Author：hoxis）
			04-likes相关的函数，
				参考了01 & 02进行简单的设计与实现
-->


	


<!-- show math formula -->



	 
	<script src="/plugin/clipboard/clipboard.js"></script>
	<script>
		// Copy code !
	    function codePreprocessing() {
	        $("#article-content .highlight").each(function() {

	            $(this).wrap('<div id="post-code"></div>');

	        })

	        $("#article-content #post-code").each(function() {

	            $(this).prepend('<nav class="copy-nav"><span><i class="code-language"></i></span></nav>');

	        })

	        $("#article-content .copy-nav").each(function() {
	            var temp = $(this).next().attr('class'),
	                language = ((temp.length > 9) && (temp != null)) ? temp.substr(10) : "none"; //why 9? Need to check language?

	            $(this).find('.code-language').text(language);

	            $(this).append('<span class="copy-btn"><i class="fa fa-copy" aria-hidden="true"></i></span>');

	        });
	    }

		function codeCopy() {
		    $('#article-content #post-code').each(function(i) {
		        var codeCopyId = 'codeCopy-' + i;

		        var codeNode = $(this).find('.code'),
		            copyButton = $(this).find('.copy-btn');

		        codeNode.attr('id', codeCopyId);
		        copyButton.attr('data-clipboard-target-id', codeCopyId);
		    })

		    
			var clipboard = new ClipboardJS('.copy-btn', {
					target: function(trigger) {
						return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
					}
		      	});

			//pure js
			function showTooltip(elem, msg) {		   
				elem.setAttribute('aria-label', msg);
				elem.setAttribute('class', 'copy-btn copy-status');
				setTimeout(function() {
					elem.setAttribute('class', 'copy-btn');
				}, 2000);
			}

			clipboard.on('success', function(e) {
			    e.clearSelection();
			    console.info('Action:', e.action);		   
			    console.info('Trigger:', e.trigger);
			    showTooltip(e.trigger, 'Copied!');
			    
			});
			clipboard.on('error', function(e) {
			    console.error('Action:', e.action);
			    console.error('Trigger:', e.trigger);
			});
		

		}

		if ($('.layout-post').length) {
		    codePreprocessing();
		    codeCopy();
		} 
	</script>





<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
<script src="/plugin/fancybox/jquery.fancybox.js"></script>

<script type="text/javascript">
	var titleID = $('.article-title a'),
		imageID = $('.article-content img'),
		videoID = $('.article-content video');

	var postTitle = titleID.text() ? titleID.text() : "No post title!";

	imageID.each(function() {
		var imgPath = $(this).attr('src'),
			imgTitle = $(this).attr('alt') ? $(this).attr('alt') : "No image description!";

		//给每个匹配的<img>元素打包, 即添加父元素<a>
		$(this).wrap('<a data-fancybox="gallery" data-caption=" 《 ' + postTitle + ' 》 ' + imgTitle + ' "  href=" ' + imgPath + ' "> </a>');
	});

	videoID.each(function() {
		var videoPath = $(this).attr('src');

		//给每个匹配的<img>元素打包, 即添加父元素<a>
		$(this).wrap('<a data-fancybox href=" ' + videoPath + ' "> </a>');
	});
	//TODO：支持html5 video

	if($('#layout-post').length) {
		$('[data-fancybox="gallery"]').fancybox({
			loop: true,
			buttons: [
				"zoom",
				"share",
				"slideShow",
				"fullScreen",
				//"download",
				"thumbs",
				"close"
			],
			protect: false
		});
	}
</script>
		</main>

		<!--footer-->
		<footer>
	<div class="social">
		<ul>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-github"></i>
			</a>
		</li>
	
		<li>
			<a href="https://weibo.com/5809441156/profile?rightmod=1&wvr=6&mod=personnumber&is_all=1" target="_blank">
				<i class="fa fa-weibo"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-pinterest"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-instagram"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-twitter"></i>
			</a>
		</li>
	
		<li>
			<a href="/atom.xml" target="_blank">
				<i class="fa fa-rss"></i>
			</a>
		</li>
			
</ul>

	</div>
		
	<div class="copyright">
		<p>
			 
				&copy;2017 - 2021, content by Sweet Coder. All Rights Reserved.
			
			
			

	<!-- busuanzi -->
	<!-- busuanzi -->

		
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	

		<span id="busuanzi_container_page_pv">
	  		本文总阅读量<span id="busuanzi_value_page_pv"></span>次
		</span>

	




		</p>
		<p>
			<a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay.
			<a href="javascript:zh_tran('s');" class="zh_click" id="zh_click_s">简体</a> 
			<a href="javascript:zh_tran('t');" class="zh_click" id="zh_click_t">繁體</a>				
		</p>
	</div>		
</footer>
		
	<!-- set '1' to show motto in all pages! -->

	<script src="/plugin/motto/motto.js"></script>
	
	<script type="text/javascript">
		$(".motto").html( getMingYanContent() );
	</script>	





<!-- love effect -->

	<script src="/plugin/love/love.js"></script>


<!-- back to top -->

	
	<div id="totop">
  		<a href="javascript:;"  name="TOTOP" class="fa fa-arrow-up" ></a>
	</div>




<!-- site analysis -->


	<!-- site-analysis -->
	
	
	
	
	
 

<script src="/plugin/vibrant/vibrant.js"></script>
<script src="/plugin/chinese/chinese.js"></script>
<script src="/plugin/imgLazyLoader/yall.min.js"></script>
<script src="/plugin/imgResize/jquery.resizeimagetoparent.min.js"></script>
<script src="/plugin/nicescroll/jquery.nicescroll.js"></script>
<script src="/js/resizediv.js"></script>
<script src="/js/main.js"></script>
	</body>	
</html>